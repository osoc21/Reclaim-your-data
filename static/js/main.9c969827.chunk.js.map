{"version":3,"sources":["constants.js","pod.js","Login.js","GridView.js","FileExplorer.js","FileUpload.js","rdf.js","Profile.js","Contacts.js","Albums.js","ContactDetails.js","BottomNavBar.js","MenuBar.js","Notification.js","Home.js","App.js","reportWebVitals.js","index.js"],"names":["GITHUB_PAGE_LINK","IMAGE_RELATIVE_PATH","METADATA_FILE_NAME","tempPodPattern","getPODUrlFromWebId","webId","match","isFolderUrl","url","endsWith","Login","props","setLoggedIn","setWebId","setPodUrl","session","a","handleIncomingRedirect","getDefaultSession","info","isLoggedIn","newPodUrl","handleRedirectAfterLogin","className","Button","size","variant","color","onClick","login","oidcIssuer","redirectUrl","window","location","href","clientName","style","marginTop","event","startIcon","GridView","files","setLoadingAnim","fileSelectMode","fileDeleteTriggered","setFileDeleteTriggered","currentPath","setNotifMsg","setNotifType","useState","entries","setEntries","openImageEntryIdx","setOpenImageEntryIdx","parsedMetadata","setParsedMetadata","loadedImagesCounter","useRef","nbImages","deleteFileFromUrl","fileUrl","deleteFile","fetch","console","log","promiseArray","entry","isSelected","push","Promise","all","promiseResults","errorMsg","i","length","shortName","filter","elem","idx","metadataFile","File","type","overwriteFile","slug","contentType","isImage","sortByDate","sort","b","date","dummyMetadataFile","name","getFile","text","fileContent","parsedContent","JSON","parse","fetchImageData","sortedContent","initEntrySelectStatus","processedEntries","raw","imageUrl","URL","createObjectURL","Response","arrayBuffer","exifData","exif","readFromBinaryFile","dateTime","DateTime","replace","undefined","Date","latitude","longitude","updateLoadingAnim","current","renderEntry","folderEntry","isFolder","borderStyle","ImageListItem","border","onLoad","loading","src","alt","prevEntries","toggleSelectedEntryAt","useEffect","readMetadataFile","deleteSelectedFiles","DialogTitle","withStyles","theme","root","margin","padding","spacing","closeButton","position","right","top","palette","grey","children","classes","onClose","other","disableTypography","Typography","IconButton","Transition","React","forwardRef","ref","Grow","timeout","handleImageModalClose","canOpenImageDetail","ImageList","rowHeight","cols","map","index","imgUrl","imgName","imgDate","Dialog","display","justifyContent","width","height","TransitionComponent","open","DialogContent","maxWidth","maxHeight","dividers","overflow","toString","showOpenImage","FileExplorer","POD_URL","podUrl","setFiles","explorerPath","setCurrentPath","setExplorerPath","getFilesFromResourceURL","getSolidDataset","fetchedFiles","getThingAll","res","slice","folderUrl","fileArray","createContainerAt","getRootFiles","Container","id","disableGutters","openFolder","then","FileUpload","selectedFiles","setSelectedFiles","upload","file","placeFileInContainer","updateMetadataFile","makeMetaDataEntry","makeMetadataFile","jsObjects","jsonString","stringify","newFileEntries","Array","from","newMetadataFile","prevContent","newContent","resContent","targetContainerURL","saveFileInContainer","selectedFilesToReact","document","querySelector","click","endIcon","multiple","accept","onChange","e","target","queryEngine","newEngine","require","executeQuery","query","sources","comunicaSources","sourceFile","store","Store","method","response","textStream","headers","get","resolve","reject","rdfParser","split","baseIRI","on","quad","addQuad","error","value","result","bindings","metadata","getEmailCardUrlQuery","getEmailFromEmailCardUrlQuery","Profile","WEB_ID","username","setUsername","role","setRole","email","setEmail","useSession","parseSingleResult","profileDocumentURI","myDataset","profile","getThing","parsedUsername","getStringNoLocale","VCARD","fn","parsedRole","parsedEmail","resBindings","parsedEmailCardUrl","showField","field","getProfileData","getContactsBasicInfoQuery","Contacts","gotoScreen","podURL","setBindings","getContactsBasicInfoSource","Contact","binding","turtleFileUrl","fetchContacts","Albums","getWebIdFromPersonFileQuery","getRoleQuery","ContactDetails","contactUsername","realProps","params","contactPersonFileUrl","routingHiddenParams","contactWebId","setContactWebId","contactPodUrl","setContactPodUrl","parsedWebId","newContactPodUrl","getContactDetailsFromPersonFile","BottomNavBar","btnClass","bottomNavBtn","setLocation","handleChange","newValue","BottomNavigation","appBar","showLabels","bottom","BottomNavigationAction","label","icon","MenuBar","setFileSelectMode","anchorEl","setAnchorEl","handleClose","AppBar","Toolbar","cursor","topBarRightFirstElem","marginLeft","edge","currentTarget","Menu","keepMounted","Boolean","MenuItem","Notification","notifMsg","notifType","Collapse","overflowY","in","Alert","severity","action","fontSize","Home","loadingAnim","setRoutingHiddenParams","history","screenPath","hiddenParams","CircularProgress","zIndex","opacity","showLoadingAnimation","exact","path","render","useStyles","makeStyles","fab","background","App","loggedIn","useHistory","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.9c969827.chunk.js","sourcesContent":["\n\nconst GITHUB_PAGE_LINK = \"https://github.com/osoc21/Reclaim-your-data\";\nconst IMAGE_RELATIVE_PATH = \"images/\";\nconst METADATA_FILE_NAME = \"metadata.json\";\n\nexport {GITHUB_PAGE_LINK, IMAGE_RELATIVE_PATH, METADATA_FILE_NAME};\n","\nconst tempPodPattern = /https:\\/\\/(\\w+\\.)solidweb.org\\/|https:\\/\\/pod\\.inrupt\\.com\\/\\w+\\//;\n\n/**\n * Takes a web id as parameter, and returns the pod url associated to it.\n * For inrupt PODs, this comes down to isolating a prefix of the web id.\n * For other pod providers, this might be different.\n * @param  {[type]} webId The web id of the user\n * @return {[type]}       The pod url associated with the web id\n */\nfunction getPODUrlFromWebId(webId) {\n    return webId.match(tempPodPattern)[0];\n}\n\n/**\n * Checks whether or not the provided URL is a folder.\n *\n * @param url {string} `URL`\n * @returns {boolean} boolean\n */\nfunction isFolderUrl(url) {\n    return url.endsWith(\"/\");\n}\n\n/**\n * Return the name of a file or folder associated with the provided URL.\n *\n * @param url {string} `URL to the file or folder.`\n * @returns {string} `Name of file.`\n */\nfunction getFileNameFromUrl(url) {\n    // let regex = /^https:\\/\\/pod\\.inrupt\\.com(\\/\\w+)*\\/(\\w+)/;\n    let name = \"\";\n    if (isFolderUrl(url))\n    {\n        console.log(\"folder!!\");\n        let slashPos = url.slice(0, url.length - 2).lastIndexOf(\"/\");\n        name = url.slice(slashPos + 1, url.length-2);\n    }\n    else\n    {\n        console.log(\"file!!\");\n        let slashPos = url.lastIndexOf(\"/\");\n        name = url.slice(slashPos + 1, url.length-1);\n    }\n    \n    return name;\n}\n\n\nexport {getPODUrlFromWebId, isFolderUrl, getFileNameFromUrl};\nexport default getPODUrlFromWebId;","\nimport {GITHUB_PAGE_LINK} from \"./constants\";\nimport \"./Login.css\";\nimport {getPODUrlFromWebId} from './pod';\nimport React from \"react\";\nimport {Button} from '@material-ui/core';\nimport GitHubIcon from '@material-ui/icons/GitHub';\nimport {\n  login,\n  handleIncomingRedirect,\n  getDefaultSession,\n} from '@inrupt/solid-client-authn-browser';\n\n\n/**\n * The Login component takes care of going to the proper POD provider login page, and handles\n * the redirect after submitting the credentials. On success, the component initializes\n * the web id, the pod url and the loggin flag of the app.\n *\n * @component\n * @param {[type]} props [description]\n */\nfunction Login(props) {\n\tlet setLoggedIn = props.setLoggedIn;\n\tlet setWebId = props.setWebId;\n\tlet setPodUrl = props.setPodUrl;\n\n\tlet session = null;\n\n\t/**\n\t * Function taken from the inrupt examples.\n\t * Starts the login process by calling the login() function.\n\t * @return {[type]} The result of the login\n\t */\n\tfunction loginToInruptDotCom() {\n\t  let chosenIssuer = \"https://broker.pod.inrupt.com\";\n\t  return login({\n\t    oidcIssuer: chosenIssuer,\n\t    redirectUrl: window.location.href,\n\t    clientName: \"Getting started app\"\n\t  });\n\t}\n\n\t/** \n\t * Function taken from the inrupt examples.\n\t * When redirected after login, finish the process by retrieving session information.\n\t * This is done with the handleIncomingRedirect() function, and then using a session object.\n\t */\n\tasync function handleRedirectAfterLogin() {\n\t  await handleIncomingRedirect();\n\n\t  session = getDefaultSession();\n\n\t  if (session.info.isLoggedIn) {\n\t    // Update the page with the status.\n\t    await setLoggedIn(true);\n\t    await setWebId(session.info.webId);\n\t    let newPodUrl = getPODUrlFromWebId(session.info.webId);\n\t    await setPodUrl(newPodUrl);\n\t  }\n\t}\n\n\thandleRedirectAfterLogin();\n\n\treturn (\n\t\t\t<div className=\"login-frame\">\n\t    \t<Button size=\"large\" variant=\"contained\" color=\"primary\" onClick={loginToInruptDotCom}>Log in with Inrupt.com</Button>\n\t    \t<Button size=\"small\" variant=\"outlined\" color=\"default\" style={{marginTop:\"10px\"}}\n          onClick={event =>  window.location.href=GITHUB_PAGE_LINK}\n          startIcon={<GitHubIcon/>}>\n          Go to Github page\n        </Button>\n    \t</div>\n\t);\n}\n\n\nexport default Login;","\nimport {METADATA_FILE_NAME} from \"./constants\";\n\nimport React, {useEffect, useState, useRef} from \"react\";\n\nimport {fetch} from '@inrupt/solid-client-authn-browser';\nimport {getFile, overwriteFile, deleteFile} from '@inrupt/solid-client';\n\nimport {ImageList, ImageListItem} from '@material-ui/core';\nimport Modal from '@material-ui/core/Modal';\nimport Container from '@material-ui/core/Container';\nimport CloseIcon from '@material-ui/icons/Close';\nimport IconButton from '@material-ui/core/IconButton';\nimport MuiDialogTitle from '@material-ui/core/DialogTitle';\nimport MuiDialogContent from '@material-ui/core/DialogContent';\nimport MuiDialogActions from '@material-ui/core/DialogActions';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport Dialog from '@material-ui/core/Dialog';\nimport Grow from '@material-ui/core/Grow';\nimport { withStyles } from '@material-ui/core/styles';\nimport Typography from '@material-ui/core/Typography';\nimport Badge from '@material-ui/core/Badge';\n\nimport dms2dec from \"dms2dec\";\nimport \"./GridView.css\";\nimport exif from 'exif-js';\n\n\n/**\n * The GridView component takes care of fetching images from the pod, getting\n * their EXIF data at the same time, and display them in a grid.\n * \n * @param {[type]} props [description]\n * @returns {JSX.Element}\n */\nfunction GridView(props) {\n    let files = props.files;\n    let setLoadingAnim = props.setLoadingAnim;\n    let fileSelectMode = props.fileSelectMode;\n    let fileDeleteTriggered = props.fileDeleteTriggered;\n    let setFileDeleteTriggered = props.setFileDeleteTriggered;\n    let currentPath = props.currentPath;\n    let setNotifMsg = props.setNotifMsg;\n    let setNotifType= props.setNotifType;\n\n    const [entries, setEntries] = useState([]);\n    let [entriesToDelete, setEntriesToDelete] = useState([]);\n    let [openImageEntryIdx, setOpenImageEntryIdx] = useState(null);\n    let [parsedMetadata, setParsedMetadata] = useState(null);\n    let loadedImagesCounter = useRef(0);\n    let nbImages = useRef(0);\n\n    useEffect(() => {\n        nbImages.current = 0;\n        loadedImagesCounter.current = 0;\n\n        if (currentPath !== \"\")\n        {\n            readMetadataFile();\n        }\n    }, [files]);\n\n    useEffect(() => {\n        if (fileDeleteTriggered)\n        {\n            deleteSelectedFiles();\n        }\n    }, [fileDeleteTriggered]);\n\n    async function deleteFileFromUrl(fileUrl) {\n        try {\n            await deleteFile(fileUrl, { fetch: fetch });\n            return true;\n        } catch (error) {\n            console.log(\"could not delete '\", fileUrl, \"'\");\n            //console.log(\"ERROR CAUGHT:\", error);\n            // Any error is handled in the UI, no need to print it to the console.\n        }\n        return false;\n    }\n\n    async function deleteSelectedFiles()\n    {\n        console.log(\"deleting selected files ...\");\n\n        await setLoadingAnim(true);\n\n        let promiseArray = [];\n\n        for (let entry of entries)\n        {\n            if (entry.isSelected)\n            {\n                promiseArray.push(deleteFileFromUrl(entry.url));\n            }\n        }\n\n        let promiseResults = await Promise.all(promiseArray);\n\n        let errorMsg = \"\";\n\n        for (let i = 0; i < promiseResults.length; ++i) {\n            let res = promiseResults[i];\n\n            // promise is false if the delete wasn't successful\n            if (!res) {\n                errorMsg += \"'\" + entries[i].shortName + \"'\";\n            }\n        }\n\n        await setLoadingAnim(false);\n\n        //there is an error or more\n        if (errorMsg !== \"\") {\n            await setNotifType(\"error\");\n            await setNotifMsg(\"Could not delete the following file(s): \" + errorMsg);\n        } else if (entries.length > 0) {\n            await setNotifType(\"success\");\n            await setNotifMsg(\"Files successfully deleted !!\");\n            // await updateMetadataFile(selectedFiles);\n        } else if (entries.length === 0) {\n            await setNotifType(\"info\");\n            await setNotifMsg(\"Nothing to delete.\");\n        }\n\n        // now we set back the flag to false\n        await setFileDeleteTriggered(false);\n\n        // remove the elements from the metadata file (which will be updated\n        // on the POD afterwards). Requires the parsedMetadata array to be sorted\n        // exactly the same way as the entries, otherwise the indexes don't match !!!!!!!!!!\n        await setParsedMetadata(parsedMetadata.filter((elem, idx) => {\n            return ! entries[idx].isSelected;\n        }));\n\n        // remove deleted entries from the array !!\n        await setEntries(entries.filter((entry) => {return ! entry.isSelected}));\n\n        let metadataFile = new File([\"[]\"], METADATA_FILE_NAME, {\n            type: \"application/json\"\n        }); \n\n        // overwrite the old metadata file\n        const savedFile = await overwriteFile(\n            currentPath + METADATA_FILE_NAME,\n            metadataFile,\n            {\n                slug: METADATA_FILE_NAME,\n                contentType: metadataFile.type,\n                fetch: fetch\n            }\n        );\n\n    }\n\n\n    /**\n     * Checks if a url is the url of a folder.\n     * @param {String} url \n     * @returns {Boolean}\n     */\n    function isFolder(url) {\n        return url.endsWith(\"/\");\n    }\n\n    /**\n     * Checks if a url is the url of an image.\n     * It currently supports .jpg/.jpeg/.png extentions.\n     * @param {String} url \n     * @returns {Boolean}\n     */\n    function isImage(url) {\n        return url.endsWith(\".jpg\") || url.endsWith(\".jpeg\") || url.endsWith(\".png\");\n    }\n\n    /*\n     *\n     * Gets the name of the deepest folder or file in the url.\n     * @param {String} url \n     * @returns {String} name of the deepest folder or file in the url\n     */\n    // function getName(url) {\n    //     let regex = /^https:\\/\\/pod\\.inrupt\\.com(\\/\\w+)*\\/(\\w+)/;\n    //     const match = url.match(regex);\n    //     // get last matched part in order to support nested folders\n    //     return match[match.length - 1];\n    // }\n\n\n    /**\n     * Sorts files by descending dates\n     * @param {FileList} files - list of files\n     * @returns {FileList} sorted list of files\n     */\n    function sortByDate(files) {\n        return files.sort((a, b) => b.date - a.date);\n    }\n\n\n    async function readMetadataFile(){\n        // initialize the file with '[]' as text content so that\n        // the file is a valid JSON file\n        let dummyMetadataFile = new File([\"[]\"], METADATA_FILE_NAME, {\n            type: \"application/json\"\n        }); \n        console.log(currentPath + dummyMetadataFile.name);\n        let metadataFile = dummyMetadataFile;\n\n        try\n        {\n            metadataFile = await getFile(currentPath + dummyMetadataFile.name, {fetch: fetch});\n            let fileContent = await metadataFile.text();\n            const parsedContent = JSON.parse(fileContent);\n\n            if(parsedContent.length > 0){\n                console.log(\"fetchingImageData\");\n                await fetchImageData(parsedContent);\n                let sortedContent = sortByDate(parsedContent);\n                // use same order as entries, but don't include the isSelected field !!\n                await setParsedMetadata(sortedContent);\n                // add the isSelected field to each entry before storing the array\n                initEntrySelectStatus(sortedContent);\n                await setEntries(sortedContent);\n            } \n     \n        }\n        // the metadata file does not exist, so we use the dummy\n        // metadata file and write it to the POD\n        catch(error)\n        {\n            const savedFile = await overwriteFile(currentPath + metadataFile.name,\n            metadataFile,\n            {\n                slug: metadataFile.name,\n                contentType: metadataFile.type,\n                fetch: fetch\n            });\n        }\n\n    }\n\n    /**\n     * Sets a isSelected attribute to each entry of the array passed as argument.\n     * @param  {[Object]} processedEntries Array containing entries, objects to which we can add attributes\n     * @return {void} Nothing\n     */\n    function initEntrySelectStatus(processedEntries)\n    {\n        for (const entry of processedEntries) {\n            if (isImage(entry.url)) {\n                entry.isSelected = false;\n            }\n        }\n    }\n\n    /**\n     * Gets image file URL (Blob) and data like EXIF DateTime and potentially location from images stored on the Solid pod.\n     * @param {Object} processedEntries \n     */\n    async function fetchImageData(processedEntries) {\n        for (const entry of processedEntries) {\n            if (isImage(entry.url)) {\n                let raw = await getFile(entry.url, {fetch: fetch});\n                entry.imageUrl = URL.createObjectURL(raw);\n                \n\n                // console.log(\"fetching EXIF\");\n                if(entry.date === null){\n                    let arrayBuffer = await new Response(raw).arrayBuffer();\n                    let exifData = exif.readFromBinaryFile(arrayBuffer);\n                    if (exifData) {\n                        let dateTime = exifData.DateTime ? exifData.DateTime.replace(\":\", \"/\").replace(\":\", \"/\") : undefined\n\n                        /*\n                        This is also the place where you would extract other EXIF data like location.\n                         */\n\n                        //let latitude = exifData.GPSLatitude && exifData.GPSLatitude[0] ? exifData.GPSLatitude : null\n                        //let longitude = exifData.GPSLongitude && exifData.GPSLongitude[0] ? exifData.GPSLongitude : null\n                        //console.log(`exifdata`);\n                        //console.log(dateTime);\n                        entry.date = new Date(dateTime);\n                        if (exifData.latitude != null && exifData.longitude != null) {\n                            // note: the dms2dec lib expects 4 parameters, but we haven't found a way to parse if the picture\n                            // was taken in the NESW direction, so at the moment it's hardcoded\n                            // TODO: extract NESW direction from EXIF data\n                            //console.log(dms2dec(exifData.latitude, \"N\", exifData.longitude, \"E\"));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /** If called with a counter of loaded images higher than the size of the entries array,\n     * stops the loading animation.\n     */\n    function updateLoadingAnim() {\n        loadedImagesCounter.current += 1;\n        if (loadedImagesCounter >= nbImages) {\n            setLoadingAnim(false);\n        }\n    }\n\n\n    /**\n     * Makes an ImageListItem for each image.\n     * @param {Object} folderEntry - entry that needs to be rendered.\n     * @param {Number} idx - index of entry in array is used as key for React list item.\n     * @returns {ReactComponent} \n     */\n    function renderEntry(folderEntry, idx) {\n        function toggleSelectedEntryAt(idx)\n        {\n            let prevEntries = [ ...entries]; // shallow copy\n            prevEntries[idx].isSelected = ! prevEntries[idx].isSelected;\n            setEntries(prevEntries);\n        }\n\n        function handleRenderedEntryClick()\n        {\n            if (fileSelectMode)\n            {\n                toggleSelectedEntryAt(idx);\n            }\n            else\n            {\n                setOpenImageEntryIdx(idx);\n            }\n        }\n\n        if ((!folderEntry.isFolder) && folderEntry.imageUrl) {\n\n            let url = folderEntry.imageUrl;\n            let selected = folderEntry.isSelected;\n            let borderStyle = (selected ? \"4px solid cyan\" : \"4px solid transparent\");\n\n            return (\n                    <ImageListItem key={idx} style={{border: borderStyle}} >\n                        <img onLoad={updateLoadingAnim} loading=\"lazy\" src={url} \n                        alt={url} onClick={handleRenderedEntryClick}/>\n                    </ImageListItem>\n                   );\n        }\n\n        return null;\n    }\n\n\n    const styles = (theme) => ({\n      root: {\n        margin: 0,\n        padding: theme.spacing(2),\n      },\n      closeButton: {\n        position: 'absolute',\n        right: theme.spacing(1),\n        top: theme.spacing(1),\n        color: theme.palette.grey[500],\n      },\n    });\n\n    const DialogTitle = withStyles(styles)((props) => {\n      const { children, classes, onClose, ...other } = props;\n      return (\n        <MuiDialogTitle disableTypography className={classes.root} {...other}>\n          <Typography variant=\"h6\">{children}</Typography>\n          {onClose ? (\n            <IconButton aria-label=\"close\" className={classes.closeButton} onClick={onClose}>\n              <CloseIcon color=\"secondary\"/>\n            </IconButton>\n          ) : null}\n        </MuiDialogTitle>\n      );\n    });\n\n    const Transition = React.forwardRef(function Transition(props, ref) {\n        return <Grow timeout={6000} ref={ref} {...props} />;\n    });\n\n\n    /**\n     * Sets the image entry index state to null, closing the image details view.\n     * @return {[type]} [description]\n     */\n    async function handleImageModalClose()\n    {\n        await setOpenImageEntryIdx(null);\n    }\n\n    /**\n     * Simple convenience function that returns true if openImageEntryIdx\n     * is defined and not null.\n     * @return {[type]} A boolean telling if openImageEntryIdx is defined and not null\n     */\n    function canOpenImageDetail()\n    {\n        // zero is implicitely converted to false\n        // but zero is a valid index !!! so check for that particular case too\n        if (openImageEntryIdx || openImageEntryIdx === 0)\n        {\n            return true;\n        }\n        return false;\n    }\n\n\n    function showOpenImage()\n    {\n        if (canOpenImageDetail())\n        {\n            let entry = entries[openImageEntryIdx];\n            let imgUrl = entry.imageUrl;\n            let imgName = entry.shortName;\n            let imgDate = entry.date;\n\n            return (<Dialog style={{margin: \"auto\", \n                    display: \"flex\", justifyContent: \"center\", \n                    width:\"100vw\", height:\"100vh\"}}\n                    TransitionComponent={Transition}\n                    open={() => {return canOpenImageDetail()}}\n                    aria-labelledby=\"simple-modal-title\"\n                    aria-describedby=\"simple-modal-description\">\n                        <DialogTitle onClose={handleImageModalClose}>\n                            {imgName ? <p>{imgName}</p> : <>&nbsp;</>}\n                        </DialogTitle>\n                        <DialogContent style={{display:\"flex\", justifyContent:\"center\"}}>\n                            <img src={imgUrl} alt={imgUrl} style={{maxWidth:\"80%\", maxHeight: \"80%\"}}/>\n                        </DialogContent>\n                        <DialogContent dividers style={{overflow: \"hidden\"}}>\n                            {imgDate ? <p>Date: {imgDate.toString()}</p> : <p>No date</p>}\n                        </DialogContent>\n                    </Dialog>);\n        }\n\n        return null;\n    }\n\n    /**\n     * Renders the ImageList with ImageListItems to be shown in the app.\n     */\n    return (\n        <div className=\"grid-view\">\n            <ImageList rowHeight={160} cols={4}>\n                {console.log(\"entries before render:\", entries)}\n                {entries.length > 0 ? entries.map((folderEntry, index) => renderEntry(folderEntry, index)) :\n                    <h4><i>Nothing to display</i></h4>}\n                {showOpenImage()}\n            </ImageList>\n        </div>\n    );\n}\n\nexport default GridView;","\nimport {IMAGE_RELATIVE_PATH} from \"./constants\"\nimport React, {useEffect, useState} from \"react\";\nimport GridView from \"./GridView\";\nimport \"./FileExplorer.css\"\nimport {fetch} from '@inrupt/solid-client-authn-browser';\nimport {getSolidDataset, getThingAll, createContainerAt} from '@inrupt/solid-client';\nimport {Container} from '@material-ui/core';\n\n\n/**\n * The FileExplorer component fetches images and updates it's state\n * once done. This allows a GridView to display the images, and can also be used\n * to implement a files and folder navigation system.\n * \n * @param {[type]} props [description]\n */\nfunction FileExplorer(props) {\n    const POD_URL = props.podUrl;\n\n    let [files, setFiles] = useState([]);\n\n    let setLoadingAnim = props.setLoadingAnim;\n    let currentPath = props.explorerPath;\n    let setCurrentPath = props.setExplorerPath;\n    let fileSelectMode = props.fileSelectMode;\n    let fileDeleteTriggered = props.fileDeleteTriggered;\n    let setFileDeleteTriggered = props.setFileDeleteTriggered;\n    let setNotifMsg = props.setNotifMsg;\n    let setNotifType = props.setNotifType;\n\n    function openFolder(url) {\n        setLoadingAnim(true);\n        // its important to set the current path first !!\n        getFilesFromResourceURL(url).then((fileArray) => {\n            setCurrentPath(url);\n            setFiles(fileArray);\n            setLoadingAnim(false);\n        });\n    }\n\n    \n\n    /**\n     * Takes an url and fetches all the files and containers at that location if possible.\n     * @param  {[type]} url The url of the container\n     * @return {[type]}     A list of file urls\n     */\n    async function getFilesFromResourceURL(url) {\n        const fetchedFiles = await getSolidDataset(url, {fetch: fetch});\n        let children = await getThingAll(fetchedFiles);\n\n        let res = []\n\n        // note: the first child element is self\n        if (children.length > 1) {\n            res = children.slice(1, children.length)\n        }\n\n        return res;\n    }\n\n\n\n\n    /** \n     * Fetch all files from the given path given relative to the root\n     * @return void\n     */\n    async function getRootFiles() {\n        let folderUrl = POD_URL + IMAGE_RELATIVE_PATH;\n        await setLoadingAnim(true);\n        try {\n            let fileArray = await getFilesFromResourceURL(folderUrl);\n            await setCurrentPath(folderUrl);\n            await setFiles(fileArray);\n            // if no files were obtained (empty folder)\n            // then stop loading animation directly\n            if (files.length === 0)\n            {\n                await setLoadingAnim(false);\n            } \n        }\n        catch(error)\n        {\n            console.log(\"Creating container at:\", folderUrl);\n            // the create container function is automatically called when overwriting\n            // files with overwriteFile(). However, here we have only read files, so we have to\n            // call createContainerAt() manually.\n            createContainerAt(POD_URL + IMAGE_RELATIVE_PATH, {fetch: fetch});\n            await setLoadingAnim(false);\n        }\n    }\n\n    useEffect(() => {\n        if (POD_URL !== \"\") {\n            getRootFiles();\n        }\n    }, [POD_URL]);\n\n\n    return (\n        <Container id=\"file-explorer\" disableGutters=\"true\">\n            <GridView files={files} openFolder={openFolder}\n            setLoadingAnim={setLoadingAnim} currentPath={currentPath}\n            fileSelectMode={fileSelectMode}\n            fileDeleteTriggered={fileDeleteTriggered} setFileDeleteTriggered={setFileDeleteTriggered}\n            setNotifMsg={setNotifMsg} setNotifType={setNotifType}/>\n        </Container>\n    );\n}\n\nexport default FileExplorer;\n","import \"./FileUpload.css\"\nimport {isFolderUrl, getFileNameFromUrl} from \"./pod\";\n\nimport React, {useState} from \"react\"\nimport {\n    saveFileInContainer,\n    getFile,\n    overwriteFile\n} from '@inrupt/solid-client';\n\nimport {\n    fetch\n} from '@inrupt/solid-client-authn-browser';\n\nimport Button from '@material-ui/core/Button';\nimport CloudUploadIcon from '@material-ui/icons/CloudUpload';\nimport SendIcon from '@material-ui/icons/Send';\n\n/**\n * The file upload component allows the user to select files, and once done,\n * display the upload button that can be clicked on the send the files on the POD.\n *\n * @component\n * @param {[type]} props The current path url (string), the notification message and type (strings)\n * and the loading animation status (bool).\n * @returns {JSX.Element}\n */\nfunction FileUpload(props) {\n    let currentPath = props.explorerPath;\n    let [selectedFiles, setSelectedFiles] = useState([]);\n    let setNotifMsg = props.setNotifMsg;\n    let setNotifType = props.setNotifType;\n    let setLoadingAnim = props.setLoadingAnim;\n\n    /**\n     * Calls placeFileInContainer for each selected file,\n     * placing all the Promises in an array before waiting for them to \n     * finish. Once all async operations are completed, the function checks if any of them\n     * failed, and if so, displays an error notification. If every operation succeeds, displays\n     * a success notification.\n     * \n     * @async\n     */\n    async function upload() {\n        let promiseArray = [];\n        await setLoadingAnim(true);\n\n        for (let file of selectedFiles) {\n            promiseArray.push(placeFileInContainer(file, currentPath));\n        }\n        let promiseResults = await Promise.all(promiseArray);\n        let errorMsg = \"\";\n\n        for (let i = 0; i < promiseResults.length; ++i) {\n            let res = promiseResults[i];\n\n            // promise is undefined if the upload wasn't successful\n            if (!res) {\n                errorMsg += \"'\" + selectedFiles[i].name + \"'\";\n            }\n        }\n\n        await setLoadingAnim(false);\n\n        // there is an error or more\n        if (errorMsg !== \"\") {\n            await setNotifType(\"error\");\n            await setNotifMsg(\"Could not upload file(s). The file(s) might already exist: \" + errorMsg);\n        } else if (selectedFiles.length > 0) {\n            await setNotifType(\"success\");\n            await setNotifMsg(\"Files successfully uploaded !!\");\n            await updateMetadataFile(selectedFiles);\n        } else if (selectedFiles.length === 0) {\n            await setNotifType(\"info\");\n            await setNotifMsg(\"Nothing to upload.\");\n        }\n    }\n\n    /**\n     * Return an object with keys **date**, **isFolder**, **imageUrl**, **shortName**, **url**.\n     *\n     * @param file {File} `File object.`\n     * @returns {{date: Date, isFolder: boolean, imageUrl: string, shortName: string, url: string}} `JS Object`\n     */\n    function makeMetaDataEntry(file) {\n        let fileUrl = currentPath + file.name;\n        let metadataEntry = {\n            url: fileUrl,\n            shortName: file.name,\n            isFolder: isFolderUrl(fileUrl),\n            imageUrl: null,\n            date: null\n        };\n        return metadataEntry;\n    }\n\n    /**\n     * Return a metadata.json file containing the entries of the files in the pod.\n     *\n     * @param jsObjects {Object[]}\n     * @returns {File} File\n     */\n    function makeMetadataFile(jsObjects) {\n        // parse the incoming JS objects to a string for the File API\n        const jsonString = `${JSON.stringify(jsObjects)}`;\n        return new File([jsonString], \"metadata.json\", {\n            type: \"application/json\"\n        });\n    }\n\n    /**\n     * Update the entries in metadata.json file with newly uploaded files to the pod.\n     *\n     * @async\n     * @returns {void} void\n     * @param {[File]} newFileEntries `Array of File to add.`\n     */\n    async function updateMetadataFile(newFileEntries) {\n        let processedEntries = Array.from(newFileEntries).map(entry => makeMetaDataEntry(entry));\n        let metadataFile = makeMetadataFile(processedEntries);\n        let file = null;\n        let newMetadataFile = null;\n\n        try\n        {\n            file = await getFile(currentPath + metadataFile.name, {fetch: fetch});\n            let fileContent = await file.text();\n            const prevContent = JSON.parse(fileContent);\n            const newContent = [...prevContent, ...processedEntries];\n            const resContent = await Promise.all(newContent);\n            newMetadataFile = makeMetadataFile(resContent);\n        }\n        catch(error)\n        {\n            newMetadataFile = makeMetadataFile(processedEntries);\n        }\n\n        const savedFile = await overwriteFile(\n            currentPath + newMetadataFile.name,\n            newMetadataFile,\n            {\n                slug: newMetadataFile.name,\n                contentType: newMetadataFile.type,\n                fetch: fetch\n            }\n        );\n    }\n\n    /**\n     * Upload file into the targetContainer.\n     * \n     * @async\n     * @param  {[type]} file               A javascript File object\n     * @param  {[type]} targetContainerURL The url of the POD container where the file should be placed\n     * @return {[string]}                  The name of the file\n     */\n    async function placeFileInContainer(file, targetContainerURL) {\n        try {\n            const savedFile = await saveFileInContainer(\n                targetContainerURL,           // Container URL\n                file,                         // File\n                {\n                    slug: file.name,\n                    contentType: file.type, fetch: fetch\n                }\n            );\n            return file.name;\n        } catch (error) {\n            //console.log(\"ERROR CAUGHT:\", error);\n            // Any error is handled in the UI, no need to print it to the console.\n        }\n    }\n\n    /**\n     * Triggers a click event on the input[type=\"file\"] element so that\n     * the associated file selecion dialog can open.\n     * @returns void\n     */\n    function openFileSelectionWindow() {\n        document.querySelector(\"#file-input\").click();\n    }\n\n    /**\n     * Convert the selected files to upload to an array of JSX.Element.\n     * Note that the `<li>` is **NOT** HTML, but a JSX.Element.\n     *\n     * @returns {[JSX.Element]} Array of JSX.Element.\n     */\n    function selectedFilesToReact() {\n        let res = [];\n        let i = 0;\n        // selectedFiles is iterable but not an array, \n        // so map() and forEach() functions don't work\n        for (let file of selectedFiles) {\n            res.push(<li key={i}>{file.name}</li>);\n            ++i;\n        }\n\n        return res;\n    }\n\n    /**\n     * Displays the list of selected files as well as a button to send them\n     * to the POD. This returned component will be displayed only if\n     * file(s) were selected beforehand.\n     * @return {JSX.Element} A div element containing the selected file(s) list and the upload button\n     */\n    function showUploadSection() {\n        return (\n            <div className=\"upload-section\">\n                <h4>Selected files:</h4>\n                <ul>{selectedFilesToReact()}</ul>\n                <Button variant=\"contained\" color=\"primary\" onClick={upload}\n                        endIcon={<SendIcon/>}>Upload</Button>\n            </div>\n        );\n    }\n\n    return (\n        <div>\n            <h1>Upload files</h1>\n            <h4>Destination:</h4>\n            <p>{currentPath}</p>\n            <Button variant=\"contained\" color=\"primary\" onClick={openFileSelectionWindow}\n                    startIcon={<CloudUploadIcon/>}>\n                Select file(s)\n            </Button>\n            {selectedFiles.length > 0 ? showUploadSection() : null}\n            <input id=\"file-input\" type=\"file\" multiple=\"multiple\"\n                   name=\"fileUploadInput\"\n                   className=\"file-selection\"\n                   accept=\"image/*\"\n                   onChange={(e) => {\n                       setSelectedFiles(e.target.files);\n                   }}/>\n        </div>\n    );\n}\n\nexport default FileUpload;\n","import { React } from \"react\";\nimport rdfParser from \"rdf-parse\";\nimport { Store } from \"n3\";\n\nconst newEngine = require('@comunica/actor-init-sparql').newEngine;\nconst queryEngine = newEngine();\n\n/**\n * Takes a RDF query and a list of source urls, and executes the query on them\n * before returning bindings for the results.\n * The session object is needed to avoid errors with the header content type.\n * @param  {[type]} query   The query to execute\n * @param  {[type]} sources The source urls, pointing to turtle files\n * @param  {[type]} session A session object reference\n * @return {[type]}         The result bindings\n */\nasync function executeQuery (query, sources, session) {\n    const comunicaSources = [];\n\n    for (let sourceFile of sources) {\n        const store = new Store();\n        const response = await session.fetch(sourceFile, { method: 'get' });\n        const textStream = require('streamify-string')(await response.text());\n        const contentType = response.headers.get('Content-Type');\n        console.log(\"Content type:\", contentType);\n        // const strippedUrl = sourceFile.split(\"#\")[0];\n        await new Promise((resolve, reject) => {\n            rdfParser.parse(textStream, { contentType: contentType.split(';')[0], baseIRI: sourceFile })\n            .on('data', (quad) => { console.log('QUAD', quad, store); store.addQuad(quad) })\n            .on('error', (error) => reject(error))\n            .on('end', async () => {resolve()})\n        });\n        comunicaSources.push({ type: 'rdfjsSource', value: store });\n    }\n\n    const result = await queryEngine.query(query, {sources: comunicaSources});\n\n    // Consume results as an array (easier)\n    const bindings = await result.bindings();\n\n    // Log metadata containing source-level provenance information\n    const metadata = await result.metadata();\n    console.log(metadata)\n\n    return bindings;\n}\n\n\nexport  {executeQuery};","\nimport React, {useState, useEffect}from \"react\";\nimport {executeQuery} from \"./rdf\";\nimport {useSession} from \"@inrupt/solid-ui-react\";\nimport { VCARD, SCHEMA_INRUPT } from \"@inrupt/vocab-common-rdf\";\nimport { fetch } from \"@inrupt/solid-client-authn-browser\";\n// Import from \"@inrupt/solid-client\"\nimport {\n  getSolidDataset,\n  getThing,\n  getStringNoLocale,\n  getUrlAll\n} from \"@inrupt/solid-client\";\n\nconst getRoleQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/2006/vcard/ns#role> ?o }\";\nconst getPODProviderUrlQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/ns/solid/terms#oidcIssuer> ?o }\";\nconst getEmailCardUrlQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/2006/vcard/ns#hasEmail> ?o }\";\n// using email card url\nconst getEmailFromEmailCardUrlQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/2006/vcard/ns#value> ?o }\";\n\n/**\n * The Profile component displays the information about the current logged-in user.\n * The information includes the web id, the pod url, the role, the username and the email.\n * Other information might be considered in the future, like the POD provider or phone numbers\n * and the like.\n *\n * @component\n * @param {[type]} props The webid (string) and the pod url (string)\n */\nfunction Profile(props)\n{\n\tconst WEB_ID = props.webId;\n\tconst POD_URL = props.podUrl;\n\tlet [username, setUsername] = useState(\"\"); //data.public;\n\tlet [role, setRole] = useState(\"\");\n\tlet [email, setEmail] = useState(\"\");\n\n\tconst { session } = useSession();\n\n\tuseEffect(() => {\n\t\tgetProfileData();\n\t}, [POD_URL]);\n\n\t/**\n\t * Simple convenience function that parses a single result in the bindings of a query.\n\t * Ideally, this function should be replaced by functions from the inrupt client API (e.g. getThing).\n\t * @param  {[type]} bindings The results of the query, from which the result should be parsed\n\t * @return {[type]}          The parsed result\n\t */\n\tfunction parseSingleResult(bindings)\n\t{\n\t\treturn bindings[0]['_root'].entries[0][1]['id'].replace(/['\"]+/g, '');\n\t}\n\n\t/**\n\t * Fetch the data of the user using the web id. The function is currently a mixture\n\t * of inrupt API functions and custom queries for the email.\n\t */\n\tasync function getProfileData()\n\t{\n\t\tconst profileDocumentURI = WEB_ID.split('#')[0];\n\n\t\t// Use `getSolidDataset` to get the Profile document.\n\t\t// Profile document is public and can be read w/o authentication; i.e.: \n\t\t// - You can either omit `fetch` or \n\t\t// - You can pass in `fetch` with or without logging in first. \n\t\t//   If logged in, the `fetch` is authenticated.\n\t\t// For illustrative purposes, the `fetch` is passed in.\n\t\tconst myDataset = await getSolidDataset(profileDocumentURI, { fetch: session.fetch });\n\n\t\tconsole.log(\"dataset:\", myDataset);\n\t\t// Get the Profile data from the retrieved SolidDataset\n\t\tconst profile = getThing(myDataset, WEB_ID);\n\t\tconsole.log(\"profile:\", profile);\n\t\t// Get the formatted name using `VCARD.fn` convenience object.\n\t\t// `VCARD.fn` includes the identifier string \"http://www.w3.org/2006/vcard/ns#fn\".\n\t\t// As an alternative, you can pass in the \"http://www.w3.org/2006/vcard/ns#fn\" string instead of `VCARD.fn`.\n \n\t\tconst parsedUsername = getStringNoLocale(profile, VCARD.fn);\n\n\t\t// Get the role using `VCARD.role` convenience object.\n\t\t// `VCARD.role` includes the identifier string \"http://www.w3.org/2006/vcard/ns#role\"\n\t\t// As an alternative, you can pass in the \"http://www.w3.org/2006/vcard/ns#role\" string instead of `VCARD.role`.\n\n\t\tconst parsedRole = getStringNoLocale(profile, VCARD.role);\n\n\t\t// let parsedEmail = getUrlAll(profile, SCHEMA_INRUPT.email);\n\t\t// console.log(\"parsed email:\", parsedEmail);\n\t\tlet parsedEmail = null;\n\t\tlet resBindings = await executeQuery(getEmailCardUrlQuery, [WEB_ID], session);\n\t\tconsole.log(\"email card url res:\", resBindings);\n\t\tif (resBindings.length > 0)\n\t\t{\n\t\t\tlet parsedEmailCardUrl = parseSingleResult(resBindings);\n\t\t\tresBindings = await executeQuery(getEmailFromEmailCardUrlQuery, [parsedEmailCardUrl], session);\n\t\t\tconsole.log(\"email res:\", resBindings);\n\t\t\tif (resBindings.length > 0)\n\t\t\t{\n\t\t\t\tparsedEmail = parseSingleResult(resBindings);\n\t\t\t}\n\t\t}\n\t\tsetUsername(parsedUsername);\n\t\tsetRole(parsedRole);\n\t\tsetEmail(parsedEmail);\n\t\t// return {username: parsedUsername, role: parsedRole};\n\t}\n\n\n\t// async function getDetailsFromWebId()\n\t// {\n\t// \tlet resBindings = await executeQuery(getRoleQuery, [WEB_ID], session);\n\t// \tconsole.log(\"role res:\", resBindings);\n\t// \tif (resBindings.length > 0)\n\t// \t{\n\t// \t\tlet parsedRole = parseSingleResult(resBindings);\n\t// \t\tsetRole(parsedRole);\n\t// \t}\n\t// \tresBindings = await executeQuery(getEmailCardUrlQuery, [WEB_ID], session);\n\t// \tconsole.log(\"email card url res:\", resBindings);\n\t// \tif (resBindings.length > 0)\n\t// \t{\n\t// \t\tlet parsedEmailCardUrl = parseSingleResult(resBindings);\n\t// \t\tresBindings = await executeQuery(getEmailFromEmailCardUrlQuery, [parsedEmailCardUrl], session);\n\t// \t\tconsole.log(\"email res:\", resBindings);\n\t// \t\tif (resBindings.length > 0)\n\t// \t\t{\n\t// \t\t\tlet parsedEmail = parseSingleResult(resBindings);\n\t// \t\t\tsetEmail(parsedEmail);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t/**\n\t * This functions displays a <p> element containing the argument if defined,\n\t * otherwise returns a <p> element containing a dash character.\n\t * @param  {[type]} field A value to display\n\t * @return {[type]}       A <p> element containing either field or a dash\n\t */\n\tfunction showField(field)\n\t{\n\t\treturn (<p>{field ? field : \"-\"}</p>);\n\t}\n\n\n\treturn (\n\t\t<>\n\t\t\t<h1>Contact page of {username}</h1>\n\t\t\t<h4>WebId:</h4>\n\t\t\t{showField(WEB_ID)}\n\t\t\t<h4>POD url</h4>\n\t\t\t{showField(POD_URL)}\n\t\t\t<h4>Email:</h4>\n\t\t\t{showField(email)}\n\t\t\t<h4>Role</h4>\n\t\t\t{showField(role)}\n\t\t</>\n\t);\n}\n\nexport default Profile;","import {useState, React, useEffect} from \"react\";\nimport {executeQuery} from \"./rdf\";\nimport \"./Contacts.css\";\nimport {useSession} from \"@inrupt/solid-ui-react\";\nimport PersonIcon from '@material-ui/icons/Person';\n\nconst getContactsBasicInfoQuery = \"SELECT ?s ?o WHERE {?s <http://www.w3.org/2006/vcard/ns#fn> ?o}\";\n\n/**\n * The Contacts components gathers the contacts of the current user.\n * The contacts are fetched using a simple rdf query, storing the results in a state variable.\n *\n * @component\n * @param {[type]} props The webId (string), the gotoScreen function and the podUrl (string)\n */\nfunction Contacts(props) {\n    let webId = props.webId;\n    let gotoScreen = props.gotoScreen;\n    let podURL = props.podUrl;\n\n    const {session} = useSession();\n    const [bindings, setBindings] = useState([]);\n\n    /**\n     * Uses the pod url to fetch the people.ttl turtle file on the POD, subsequently being able\n     * to query the file for contact names and their associated 'person-files'.\n     * The result bindings are stored in a state variable. \n     */\n    async function fetchContacts() {\n        let getContactsBasicInfoSource = podURL + \"contacts/people.ttl#this\";\n        let resBindings = await executeQuery(getContactsBasicInfoQuery, [getContactsBasicInfoSource], session);\n        await setBindings(resBindings);\n    }\n\n    useEffect(() => {\n        fetchContacts();\n    }, [webId]);\n\n    /**\n     * The Contact component encapsulates the name of the user and it 'person-file' url,\n     * and allows the user to click on it to display more data about the contact.\n     * When clicked, a page switch is triggered by changing the path of the router\n     * and parameterize it with the name of the person.\n     * Notice that the person-file url is actually used to get the contact details, but is passed\n     * to the router in a hidden way to have a clearer url displayed in the browser and avoid unescaped\n     * character problems.\n     * @param {[type]} props The bindings of the result\n     * @return {[type]} A div component containing an icon (ideally a profile pic) and the name of the contact,\n     * which can be clicked on to move to the contact details page\n     */\n    function Contact(props) {\n        let binding = props.binding;\n\n        let username = binding['_root'].entries[1][1]['id'].replace(/['\"]+/g, '');\n        let turtleFileUrl = binding['_root'].entries[0][1]['id'].replace(/['\"]+/g, '');\n\n        return (\n            <div className=\"contact\">\n                <PersonIcon/>\n                <p className=\"contact-name\"\n                   onClick={() => gotoScreen(`/contacts/${username}`, [turtleFileUrl])}>{username}</p>\n            </div>\n        );\n    }\n\n    return (\n        <div>\n            <h1>Contacts</h1>\n            {bindings.map((binding, idx) => {\n                console.log(\"Binding:\", binding);\n                return (<Contact key={idx} binding={binding}/>)\n            })}\n        </div>\n    );\n}\n\nexport default Contacts;","\nimport React from \"react\";\n\n/**\n * The Albums component displays folder like structures that gather\n * images according to tags or location on the POD. Consequently, the implementation\n * of the component is heavily implementation dependent: files can be grouped\n * according to their parent folder on the POD, or according to index files\n * and dynamic faceted search algorithms. Currently, the Albums component is filled with dummy\n * data.\n *\n * @component\n * @param {[type]} props [description]\n */\nfunction Albums(props)\n{\n\treturn (\n\t\t<>\n\t\t\t<h1>Albums</h1>\n\t\t\t<h2>Your albums</h2>\n\t\t\t<p>album1</p>\n\t\t\t<p>album1</p>\n\t\t</>\n\t);\n}\n\nexport default Albums;","import React, {useState, useEffect} from \"react\";\nimport {executeQuery} from \"./rdf\";\nimport {getPODUrlFromWebId} from './pod';\nimport {useSession} from \"@inrupt/solid-ui-react\";\n\n// using person file as source\nconst getWebIdFromPersonFileQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/2006/vcard/ns#value> ?o }\";\n// using webid as source\nconst getRoleQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/2006/vcard/ns#role> ?o }\";\n// const getPODProviderUrlQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/ns/solid/terms#oidcIssuer> ?o }\";\nconst getEmailCardUrlQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/2006/vcard/ns#hasEmail> ?o }\";\n// using email card url\nconst getEmailFromEmailCardUrlQuery = \"SELECT ?o WHERE { ?s <http://www.w3.org/2006/vcard/ns#value> ?o }\";\n\n/**\n * The ContactDetails component gathers information about a given contact.\n * The data is fetched from the POD using a 'person-file' url received from the parent\n * Contacts component. Note that this file url is not received as a prop of the router which\n * has to pass by the url, but as a hidden state variable of the app.\n *\n * @component\n * @param {[type]} props [description]\n */\nfunction ContactDetails(props)\n{\n\tlet contactUsername = props.realProps.match.params.username; //data.public;\n\tlet contactPersonFileUrl = props.routingHiddenParams[0]; //data.hidden;\n\tlet [contactWebId,setContactWebId] = useState(\"\");\n\tlet [contactPodUrl, setContactPodUrl] = useState(\"\");\n\tlet [role, setRole] = useState(\"\");\n\tlet [email, setEmail] = useState(\"\");\n\n\tconst { session } = useSession();\n\n\t/**\n\t * Simple convenience function that parses a single result in the bindings of a query.\n\t * Ideally, this function should be replaced by functions from the inrupt client API (e.g. getThing).\n\t * @param  {[Object]} bindings The results of the query, from which the result should be parsed\n\t * @return {[string]}          The parsed result\n\t */\n\tfunction parseSingleResult(bindings)\n\t{\n\t\treturn bindings[0]['_root'].entries[0][1]['id'].replace(/['\"]+/g, '');\n\t}\n\n\t/**\n\t * This function use hardcoded predicates to query the person file and get information\n\t * like the role, email or webid of a contact. This function could be refactored\n\t * to use functions and vocabulary (e.g. VCARD) from the inrupt library.\n\t */\n\tasync function getContactDetailsFromPersonFile()\n\t{\n\t\tlet resBindings = await executeQuery(getWebIdFromPersonFileQuery, [contactPersonFileUrl], session);\n\t\tlet parsedWebId = parseSingleResult(resBindings);\n\t\t//console.log(\"parsed contact webid:\", parsedWebId);\n\t\tsetContactWebId(parsedWebId);\n\t\tlet newContactPodUrl =  getPODUrlFromWebId(parsedWebId);\n\t\tsetContactPodUrl(newContactPodUrl);\n\t\tresBindings = await executeQuery(getRoleQuery, [parsedWebId], session);\n\t\t//console.log(\"role res:\", resBindings);\n\t\tif (resBindings.length > 0)\n\t\t{\n\t\t\tlet parsedRole = parseSingleResult(resBindings);\n\t\t\tsetRole(parsedRole);\n\t\t}\n\t\tresBindings = await executeQuery(getEmailCardUrlQuery, [parsedWebId], session);\n\t\t//console.log(\"email card url res:\", resBindings);\n\t\tif (resBindings.length > 0)\n\t\t{\n\t\t\tlet parsedEmailCardUrl = parseSingleResult(resBindings);\n\t\t\tresBindings = await executeQuery(getEmailFromEmailCardUrlQuery, [parsedEmailCardUrl], session);\n\t\t\t//console.log(\"email res:\", resBindings);\n\t\t\tif (resBindings.length > 0)\n\t\t\t{\n\t\t\t\tlet parsedEmail = parseSingleResult(resBindings);\n\t\t\t\tsetEmail(parsedEmail);\n\t\t\t}\n\t\t}\n\t\t// let email =\n\t}\n\n\tuseEffect(() => {\n\t\tgetContactDetailsFromPersonFile();\n\t}, [contactPersonFileUrl]);\n\t\n\t/**\n\t * This functions displays a <p> element containing the argument if defined,\n\t * otherwise returns a <p> element containing a dash character.\n\t * @param  {[type]} field A value to display\n\t * @return {[type]}       A <p> element containing either field or a dash\n\t */\n\tfunction showField(field)\n\t{\n\t\treturn (<p>{field ? field : \"-\"}</p>);\n\t}\n\n\n\treturn (\n\t\t<>\n\t\t\t<h1>Contact page of {contactUsername}</h1>\n\t\t\t<h4>Person file url:</h4>\n\t\t\t{showField(contactPersonFileUrl)}\n\t\t\t<h4>WebId:</h4>\n\t\t\t{showField(contactWebId)}\n\t\t\t<h4>POD url</h4>\n\t\t\t{showField(contactPodUrl)}\n\t\t\t<h4>Email:</h4>\n\t\t\t{showField(email)}\n\t\t\t<h4>Role</h4>\n\t\t\t{showField(role)}\n\t\t</>\n\t);\n}\n\nexport default ContactDetails;","\nimport React, {useState} from \"react\";\nimport {BottomNavigation, BottomNavigationAction} from '@material-ui/core';\nimport PhotoIcon from '@material-ui/icons/Photo';\nimport AccountBoxIcon from '@material-ui/icons/AccountBox';\nimport FolderIcon from '@material-ui/icons/Folder';\nimport GroupIcon from '@material-ui/icons/Group';\n\n\n/**\n * The BottomNavBar component extends a material-ui BottomNavigation component\n * to support routing in a fixed bar at the bottom of the screen.\n * This allows the app to navigate between pages while having a flexible\n * approach, especially for simple and intuitive mobile navigation.\n *\n * @component\n * @param {[type]} props [description]\n */\nfunction BottomNavBar(props) {\n    let classes = props.classes;\n    let btnClass = classes.bottomNavBtn;\n    let gotoScreen = props.gotoScreen;\n    let [location, setLocation] = useState(\"/\");\n\n    /**\n     * Event handler called each time that the bottom navigation is clicked and a page switch\n     * should take place. The gotoScreen function is then called and the the focus of the bottom\n     * navigation is updated.\n     * @param  {[type]} event    The change event for the bottom navigation element\n     * @param  {[string]} newValue The new string value of the bottom navigation, which is the new path for the router\n     */\n    const handleChange = async (event, newValue) => {\n        await setLocation(newValue);\n        await gotoScreen(newValue)\n    };\n\n    return (\n        <BottomNavigation className={classes.appBar} value={location} onChange={handleChange}\n                          showLabels style={{position: 'fixed', width: \"100%\", bottom: 0}}>\n            <BottomNavigationAction className={btnClass} value=\"/\" label=\"Photos\" icon={<PhotoIcon/>}/>\n            <BottomNavigationAction className={btnClass} value=\"/albums\" label=\"Albums\" icon={<FolderIcon/>}/>\n            <BottomNavigationAction className={btnClass} value=\"/profile\" label=\"Profile\" icon={<AccountBoxIcon/>}/>\n            <BottomNavigationAction className={btnClass} value=\"/contacts\" label=\"Contacts\" icon={<GroupIcon/>}/>\n        </BottomNavigation>\n    );\n}\n\nexport default BottomNavBar;","\nimport {GITHUB_PAGE_LINK} from \"./constants\";\n\nimport React from \"react\";\nimport {AppBar, Toolbar, Typography} from '@material-ui/core';\nimport AddIcon from '@material-ui/icons/Add';\nimport IconButton from '@material-ui/core/IconButton';\nimport GitHubIcon from '@material-ui/icons/GitHub';\nimport DeleteIcon from '@material-ui/icons/Delete';\nimport MoreVertIcon from '@material-ui/icons/MoreVert';\nimport Menu from '@material-ui/core/Menu';\nimport MenuItem from '@material-ui/core/MenuItem';\n\n/**\n * The MenuBar component represent a sticky bar at the top of the app, including\n * a label and ideally a logo in the future. The bar should also include quick access \n * functionnalities, which are currently limited to a button opening the file upload page.\n * @param {[type]} props [description]\n */\nfunction MenuBar(props) {\n    let classes = props.classes;\n    let gotoScreen = props.gotoScreen;\n    let fileSelectMode = props.fileSelectMode;\n    let setFileSelectMode = props.setFileSelectMode;\n    let setFileDeleteTriggered = props.setFileDeleteTriggered;\n\n    /* The anchor code was taken from material-ui Menu component examples */\n\n    const [anchorEl, setAnchorEl] = React.useState(null);\n\n    const handleClick = (event) => {\n        setAnchorEl(event.currentTarget);\n    };\n\n    const handleClose = () => {\n        setAnchorEl(null);\n    };\n\n    return (\n        <AppBar position=\"sticky\" className={classes.appBar}>\n            <Toolbar>\n                <Typography variant=\"h6\" color=\"inherit\">\n                    WePod\n                </Typography>\n                <GitHubIcon style={{cursor: \"pointer\"}} className={classes.topBarRightFirstElem} \n                onClick={event =>  window.open(GITHUB_PAGE_LINK, '_blank', \"\", false) }/>\n                <IconButton style={{color: \"white\", marginLeft:\"10px\"}} edge=\"start\"\n                    aria-label=\"menu\" aria-controls=\"simple-menu\" aria-haspopup=\"true\" onClick={handleClick}>\n                  <MoreVertIcon/>\n                </IconButton>\n                <Menu\n                  anchorEl={anchorEl}\n                  keepMounted\n                  open={Boolean(anchorEl)}\n                  onClose={handleClose}\n                >\n                  <MenuItem onClick={() => {handleClose(); gotoScreen('/upload');}}>Upload</MenuItem>\n                  <MenuItem onClick={() => {handleClose(); setFileSelectMode(! fileSelectMode)}}>Modify</MenuItem>\n                </Menu>\n                {fileSelectMode ? <IconButton style={{color: \"white\"}} edge=\"start\"\n                            aria-label=\"menu\" onClick = {() => {setFileSelectMode(false);\n                                setFileDeleteTriggered(true);}}>\n                    <DeleteIcon/>\n                </IconButton> : null}\n                {/*<IconButton style={{color: \"white\", marginLeft: \"10px\"}} edge=\"start\"\n                            aria-label=\"menu\" onClick={async () => {\n                    await gotoScreen('/upload')\n                }}>\n                    <AddIcon/>\n                </IconButton>\n                <IconButton style={{color: \"white\"}} edge=\"start\"\n                            aria-label=\"menu\" onClick = {() => {setFileSelectMode(! fileSelectMode)}}>\n                    <DeleteIcon/>\n                </IconButton>*/}\n            </Toolbar>\n        </AppBar>\n    );\n}\n\nexport default MenuBar;","\nimport React from \"react\";\nimport Alert from '@material-ui/lab/Alert';\nimport Collapse from '@material-ui/core/Collapse';\nimport IconButton from '@material-ui/core/IconButton';\nimport CloseIcon from '@material-ui/icons/Close';\n\n/**\n * The Notification component implements the UI and logic for notifications,\n * displaying the proper notification message prop depending on the notification type prop.\n * Note that the notification type should be a string accepted by the material-ui Alert component.\n *\n * @see {@link https://material-ui.com/components/alert/}\n * @param {[type]} props A valid Alert type (string), a notification message (string) and a setter function\n * for the message.\n */\nfunction Notification(props) {\n    let notifMsg = props.notifMsg;\n    let notifType = props.notifType;\n    let setNotifMsg = props.setNotifMsg;\n\n    return (<Collapse style={{overflowY: \"scroll\"}} in={(notifMsg !== \"\" && notifType !== \"\")}>\n        <Alert severity={notifType} action={\n            <IconButton\n                aria-label=\"close\"\n                color=\"inherit\"\n                size=\"small\"\n                onClick={() => {\n                    setNotifMsg(\"\");\n                }}>\n                <CloseIcon fontSize=\"inherit\"/>\n            </IconButton>}>\n            {notifMsg}\n        </Alert>\n    </Collapse>);\n}\n\nexport default Notification;","\nimport FileExplorer from \"./FileExplorer\";\nimport FileUpload from \"./FileUpload\";\nimport Profile from \"./Profile\";\nimport Contacts from \"./Contacts\";\nimport Albums from \"./Albums\";\nimport ContactDetails from \"./ContactDetails\";\nimport BottomNavBar from \"./BottomNavBar\";\nimport MenuBar from \"./MenuBar\";\nimport Notification from \"./Notification\";\n\nimport React, {useState} from \"react\";\nimport CircularProgress from '@material-ui/core/CircularProgress';\n\nimport { Switch, Route } from \"react-router-dom\";\n\n\n/**\n * The Home component handles the application logic and UI once logged-in to access the POD. The component\n * relies on react router to switch between pages, with the root being the image gallery. The component\n * also contains menu bars to interact with the content, and can display notifications and loading animations.\n *\n * @component\n * @param {[type]} props [description]\n */\nfunction Home(props) {\n    /**\n     * State containing notification messages.\n     */\n    let [notifMsg, setNotifMsg] = useState(\"\");\n\n    /**\n     * State containing the notification type, which should be a string value accepted\n     * by the material UI Alert component (\"error\", \"info\", \"warning\", \"success\").\n     *\n     * @see {@link https://material-ui.com/components/alert/}\n     * \n     */\n    let [notifType, setNotifType] = useState(\"info\");\n\n    /**\n     * Boolean state telling whether or not a loading animation is to be displayed.\n     */\n    let [loadingAnim, setLoadingAnim] = useState(false);\n\n    /**\n     * State containing hidden routing parameters.\n     */\n    let [routingHiddenParams, setRoutingHiddenParams] = useState([]);\n\n    /**\n     * State used to enable or disable the file select mode.\n     */\n    let [fileSelectMode, setFileSelectMode] = useState(false);\n\n    /**\n     * State used to trigger a file delete operation for selected files.\n     */\n    let [fileDeleteTriggered, setFileDeleteTriggered] = useState(false);\n\n    let webId = props.webId;\n    let podUrl = props.podUrl;\n    let explorerPath = props.explorerPath;\n    let setExplorerPath = props.setExplorerPath;\n    let history = props.history;\n\n    const classes = props.classes;\n\n   \n    /**\n     * This function changes the route that should be taken by the router by appending\n     * the new path to the browser history, and cancels any loading animation running.\n     * Hidden parameters can also be passed to the function\n     * without being exposed in the url (displayed in the browser). This is particularly useful\n     * when the data contains sepcial characters that could mess with the routing (e.g. ':', '#' or '/')\n     * or when the parameter is too long and makes it difficult to debug the routing by looking at the \n     * browser url. Notice that if hiddenParams is not empty, it means that the page we want to load\n     * expects these parameters to be set beforehand, hence we first set the hidden parameters\n     * before initiating the page switch. On the other hand, if the hiddenParams is null,\n     * then we first want to render the new page before assigning null to the routingHiddenParams state.\n     * This is because the previous page might have a prop that references the routingHiddenParam state,\n     * hence setting it to null while the component is still there would generate an error.\n     * @param  {[type]}  screenPath               The new path for the router, pushed to the history\n     * @param  {[type]}  hiddenParams             Params that will be used by the new page, but don't go in the path url\n     */\n    async function gotoScreen(screenPath, hiddenParams = null) {\n        // hiddenParams is defined and not null\n        // ==> update the state before moving to the new page\n        if (hiddenParams) {\n            await setRoutingHiddenParams(hiddenParams);\n        }\n\n        await setLoadingAnim(false); // always cancel loading anim when switching screen\n        history.push(`${screenPath}`);\n\n        // hiddenParams is null, so we set it after the page change\n        if (! hiddenParams) {\n            await setRoutingHiddenParams(null);\n        }\n    }\n\n    /**\n     * Displays a fixed loading animation centered on the screen when the loadingAnim state is set to true.\n     * The animation is top level, hence it has a z-index higher than the other components, and it floats\n     * as the user scrolls the page.\n     *\n     * @see {@link https://material-ui.com/api/circular-progress/}\n     * @return {[CircularProgress]}  A styled material-ui CircularProgress element\n     */\n    function showLoadingAnimation() {\n        if (loadingAnim) {\n            return <CircularProgress color=\"secondary\" size={100}\n                    style={{zIndex: 1700, opacity: \".7\", position: \"fixed\", top: \"45vh\"}}/>\n        }\n    }\n\n\n    return (<>\n        {showLoadingAnimation()}\n        <MenuBar classes={classes} history={history} gotoScreen={gotoScreen} \n        fileSelectMode={fileSelectMode} setFileSelectMode={setFileSelectMode}\n        setFileDeleteTriggered={setFileDeleteTriggered}/>\n        <Notification setNotifMsg={setNotifMsg} notifMsg={notifMsg} notifType={notifType}/>\n        <div className=\"content\">\n            <Switch>\n                <Route exact path=\"/upload\">\n                    <FileUpload explorerPath={explorerPath} setNotifMsg={setNotifMsg}\n                                setNotifType={setNotifType} setLoadingAnim={setLoadingAnim}/>\n                </Route>\n                <Route exact path=\"/profile\">\n                    <Profile webId={webId} podUrl={podUrl}/>\n                </Route>\n                <Route exact path=\"/contacts\">\n                    <Contacts gotoScreen={gotoScreen} podUrl={podUrl}/>\n                </Route>\n                <Route path=\"/contacts/:username\"\n                       render={(props) => <ContactDetails routingHiddenParams={routingHiddenParams} realProps={props}/>}/>\n                <Route exact path=\"/albums\">\n                    <Albums/>\n                </Route>\n                <Route exact path=\"/\">\n                    <FileExplorer podUrl={podUrl} explorerPath={explorerPath}\n                                  setExplorerPath={setExplorerPath} setLoadingAnim={setLoadingAnim}\n                                  fileSelectMode={fileSelectMode}\n                                  fileDeleteTriggered={fileDeleteTriggered} setFileDeleteTriggered={setFileDeleteTriggered}\n                                  setNotifMsg={setNotifMsg} setNotifType={setNotifType}/>\n                </Route>\n            </Switch>\n        </div>\n        <BottomNavBar classes={classes} gotoScreen={gotoScreen}/>\n    </>);\n}\n\nexport default Home;","\n\nimport './App.css';\nimport Login from \"./Login\";\nimport Home from \"./Home\";\n\nimport React, {useState, useEffect} from \"react\";\nimport {useHistory} from \"react-router-dom\";\nimport {makeStyles} from \"@material-ui/core/styles\";\n\n\n// Style I want for fab, can add more - it's just a JS object\nconst useStyles = makeStyles({\n    fab: {\n        position: \"fixed\",\n        right: \"10px\",\n        bottom: \"10px\",\n    },\n    topBarRightFirstElem: {\n        marginLeft: 'auto',\n    },\n    appBar: {\n        background: 'rgba(0,0,0,0.9)',\n    },\n    bottomNavBtn: {\n        color: \"grey\",\n        \"&$selected\": {\n            color: \"red\"\n        }\n    }\n});\n\n\n/**\n * The App component displays a Login page from which the user can login to a POD.\n * One logged-in, the App will display the home screen instead.\n *\n * @component\n */\nfunction App() {\n    /**\n     * State telling if the user is logged in or not.\n     */\n    let [loggedIn, setLoggedIn] = useState(false);\n\n    /**\n     * The web id of the user.\n     */\n    let [webId, setWebId] = useState(\"\");\n\n    /**\n     * The url of the user's POD.\n     */\n    let [podUrl, setPodUrl] = useState(\"\");\n\n    /**\n     * Current path in the file explorer, which can be used when sub-folders\n     * can be navigated.\n     */\n    let [explorerPath, setExplorerPath] = useState(\"\");\n\n    let history = useHistory();\n    const classes = useStyles();\n\n    useEffect(() => {\n        setExplorerPath(podUrl);\n    }, [podUrl]);\n\n    /**\n     * Returns true if the user is logged in and the web id is set.\n     * @return {Boolean} The login status\n     */\n    function isLoggedIn() {\n        return (webId !== \"\") && loggedIn;\n    }\n\n    /**\n     * Convenience function that creates the login component.\n     * @return {[type]} The login component\n     */\n    function getLoginComponent() {\n        return (<>\n                <Login setWebId={setWebId} setLoggedIn={setLoggedIn} setPodUrl={setPodUrl}/>\n                </>);\n    }\n\n    /**\n     * Convenience function that creates the home component.\n     * @return {[type]} [description]\n     */\n    function getHomeComponent() {\n        return <Home classes={classes}\n                     webId={webId} podUrl={podUrl}\n                     history={history}\n                     explorerPath={explorerPath}\n                     setExplorerPath={setExplorerPath}/>;\n    }\n\n\n    return (\n        <div className=\"app-div\">\n            {isLoggedIn() ? getHomeComponent() : getLoginComponent()}\n        </div>\n    );\n}\n\n\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport {HashRouter} from \"react-router-dom\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <HashRouter>\n            <App/>\n        </HashRouter>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}